% Created 2015-12-13 Sun 11:26
\documentclass[graduation-thesis]{mlarticle}
     \usepackage[dvipdfmx]{graphicx}
     \usepackage{url}
     \usepackage{atbegshi}
     \AtBeginShipoutFirst{\special{pdf:tounicode EUC-UCS2}}
     \usepackage[dvipdfmx,setpagesize=false]{hyperref}
          \usepackage[dvipdfmx]{color}
\usepackage{url}
\usepackage{float}
\usepackage[setpagesize=false]{hyperref}
\usepackage{ascmac}
\usepackage{here}
\usepackage{txfonts}
\usepackage{listings, jlisting}
\author{61200185 情報工学科 縣直道}
\date{\today}
\title{}
\begin{document}


\makeatletter
\renewcommand{\thetable}{
        \thesection.\arabic{table}
} %「表（章番号）-#.」と表記するための措置
\@addtoreset{table}{section}
  
\renewcommand{\thefigure}{
        \thesection.\arabic{figure}
}
\@addtoreset{figure}{section} %「図（章番号）-#.」と表記するための措置

\setcounter{page}{1}

\pagenumbering{roman}
\tableofcontents
\clearpage

\pagenumbering{arabic}

\definecolor{keywords}{RGB}{255,0,90}
\definecolor{comments}{RGB}{0,0,113}
\definecolor{red}{RGB}{160,0,0}
\definecolor{green}{RGB}{0,150,0}
 
\lstset{
        basicstyle=\ttfamily\footnotesize, 
        frame=single,
        keywordstyle=\color{keywords},
        commentstyle=\color{comments},
        stringstyle=\color{red},
        showstringspaces=false,
        identifierstyle=\color{green},
        }
\section{はじめに}
\label{intro}
\subsection {背景}
\label {intro:background}
現在，仮想化技術が普及してきており，様々なサービスの基盤技術として広く用いられている．
仮想化技術の利用例として，クラウドコンピューティングやInfrastructure as a Service (IaaS) が挙げられる．
物理マシンという限られたリソースを仮想化することで，複数の利用者が安全にリソースを共有することが可能となる．
IaaS は仮想化されたコンピュータ基盤をインターネット経由でサービスとして提供するものである．

クラウド環境上では，一台の仮想マシン上で，一つのアプリケーションのみを実行する場合がほとんどである．
これは，クラウド環境上では，物理マシンというリソースを増やすことなく仮想マシンを増やすことが可能であり，複数のアプリケーションを実行する場合には仮想マシンを増やすことで対処可能なためである．

このようなクラウド環境上の仮想マシンには，ほとんどの場合，物理マシン上で利用されるような汎用オペレーティングシステム(Linux，Windows，*BSD)が利用される．

\subsection {問題点}
\label {intro:problem}
汎用オペレーティングシステムは，高度な抽象化，機能を多数備えている．
オペレーティングシステム上で動作するアプリケーションが固定されている場合，それらの抽象化，機能は不要となる．

クラウド環境上の仮想マシンでは，ほとんどの場合，動作するアプリケーションが固定されている．
仮想マシンに汎用オペレーティングシステムを利用する場合，使用されることのないオペレーティングシステムの機能のために，カーネルイメージのサイズが増大し，セキュリティにも問題を抱えることになる． 
カーネルイメージのサイズが大きいと仮想マシンのサイズも大きくなり，仮想マシンの起動時間も大きくなる．
クラウド環境では，一つのアプリケーションごとに一台の仮想マシンを立ち上げるため，これらは大きな問題となる．

この問題の解決案として，あるアプリケーションに特化したオペレーティングシステムを開発するという方法が考えられる．
しかし，この方法は現実的とは言えない．オペレーティングシステムの開発は難しく，誤った実装が行われた場合システム全体に影響を及ぼしてしまう．
さらに，アプリケーションごとに新たにオペレーティングシステムを開発する必要があるという問題もある．

\subsection {提案}
\label{intro:proposal}
本研究では，汎用オペレーティングシステムから，アプリケーションが必要としない機能を自動的に削除することで，アプリケーションに特化したカーネルを生成する．
アプリケーションのソースコードを静的解析することで，必要となるオペレーティングシステムの機能を絞り込み，ブートに必要な部分と絞り込んだ機能を実装している部分のみを残すよう，カーネルのソースコードを書き換える．
自動的にカーネルを改変することで，アプリケーションごとに特化したオペレーティングシステムを開発する必要があるという問題点を解決する．

\subsection {実装}
\label{intro:implementation}
% TODO: gcov と openstack のリファレンス
まず，Linux カーネルソースコードの内，ブートに必要な部分とそうでない部分を分類する必要がある．
アプリケーションが使用する機能以外のすべてのソースコードを削除してしまうとブートすることが出来ないオペレーティングシステムになってしまう．
本研究では，この分類を行う手法を実装した．

本研究では，ブートに必要な部分を判別するため，gcov を用い，ブートまでのコードカバレッジを取得した．
ここから，ブートまでに一度も実行されていなかった関数を判別することができる．

ブートまでに一度も実行されていなかった関数をすべて削除したカーネルはブートすることが出来なかったため，Open Stack 上でカーネルがブートすることをテストできる環境を構築し，現在実験中である．

\subsection {論文の構成}
\label{intro:arch}
本論文の構成をいかに示す．
第\ref{relative}章では，本研究と関連する研究を紹介する．

\section {関連研究}
\label{relative}



本章では，本研究と関連する研究を紹介する．
Exokernel は，極小さなカーネルに，ライブラリとして高度な機能を付加する構成を提案している．
OSv は，仮想マシン上で一つのアプリケーションのみを実行する環境に特化したオペレーティングシステムを開発した．
Unikernel は，カーネルコンパイル時に，オペレーティングシステムの機能の有無を設定することができるカーネルである．

\subsection {Exokernel: An Operating System Architecture for Application-Level Resource Management}
\label{relarive:exokernel}
カーネルのサイズを小さくするために，極単純な機能のみを持つカーネルに，Library OS として高レベルな抽象化などの機能を付加するという構成を提案している．

中心となる極小さなカーネルは，ハードウェア資源にアクセスするための低レベルなインターフェースを提供する役割のみを持つ．
プロセス，ファイル，アドレス空間，プロセス間通信といった高レベルな抽象化は，カーネルの提供するインターフェースを用いて，すべてカーネル外のライブラリとして実装される．
このような構成にすることで，アプリケーションが必要とする抽象化のみを提供することができ，アプリケーションが直接ハードウェア資源にアクセスすることも可能となる．
また，アプリケーションが必要とする機能のみをもつオペレーティングシステムを構築できるため，オペレーティングシステムによるオーバヘッドやメモリ使用量の増加といった問題を解決することができる．

% TODO: Exokernel の本研究との関連をうまく説明

Exokernel の構成では，アプリケーションを変えると，そのアプリケーションが必要とする抽象化を選択し再構成する必要が生じる．

\subsection {OSv - Optimizing the Operating System for Virtual Machines}
\label{relative:unikernel}
OSv は，一つのアプリケーションをクラウド環境上で実行することに特化したオペレーティングシステムである．

標準的な仮想マシンの構成を図\ref{fig:vm}に示す．
仮想マシンでは，ハードウェアをハイパーバイザが仮想化し，ハイパーバイザ上でオペレーティングシステムが動作する．

仮想マシン上で一つのアプリケーションのみを実行する場合，オペレーティングシステムが持つハードウェア抽象化やプロセス間Isolationといった役割は，ハイパーバイザが担っており，不要な抽象化が重なりオーバヘッドになる．

\ref{intro:background}で述べたように，クラウド環境上の仮想マシンでは，一つのアプリケーションのみを実行する場合がほとんどである．
仮想マシン上で一つのアプリケーションのみを実行するという環境では，
アプリケーションにバグがあったり，悪意あるアプリケーションが動作した場合であっても，
仮想マシン上ではそのアプリケーションしか実行されておらず，同じ物理マシン上で動作する他の仮想マシンは，ハイパーバイザによって保護されているため影響を受けない．

OSvは，仮想マシン上で一つのアプリケーションのみを実行することを前提にし，ハードウェア抽象化やプロセス間Isolationの機能をオペレーティングシステムから削除した．
また，Posix API互換のAPIと独自のAPIを提供している．Posix API互換のAPIでは，システムコールは単なる関数呼び出しに過ぎず，Linuxなどにおけるシステムコールが必要とする，ユーザモードから特権モードへの切り替えや引数のコピーなどは行われない．
このようにすることで，Linux上で動作していたネットワークインテンシブなアプリケーションについて，25％のスループット向上，47％のレイテンシ削減を，アプリケーションを改変することなく実現した．
また，OSv独自のネットワークAPIを使用するようアプリケーションの改変を行い，スループットが290％向上した．

OSvは，仮想マシン上で一つのアプリケーションのみを実行する環境に特化したオペレーティングシステムを開発したが，
実行するアプリケーションに特化したオペレーティングシステムを提供する手法ではない．
また，その前提上，forkやexecといった関数は提供されていないため，これらを用いるアプリケーションを実行することが出来ない．


\subsection {Unikernel: Library Operating Systems for the Cloud}
\label{relative:unikernel}
Unikernelは，コンパイル時に，オペレーティングシステムが提供する機能の有効，無効を設定することができるカーネルを提案した．
OSvと同様に，仮想マシン上で一つのアプリケーションのみを実行する環境を想定し，
そのアプリケーションが必要としないオペレーティングシステムの機能を無効にしてコンパイルすることで，
カーネルのサイズを縮小し，無駄なコードを削減した．

% TODO: library os で一つのサブセクションにして，その中でUnikernelとExokernelを紹介する？OSvもLibrary OSなのでまとめるべき？
% TODO: Dune や Arrakis はどうやって紹介するか


\section{提案}
\label{proposal}

\subsection{概要}
\label{proposal:abstruction}
本研究では，クラウド環境を想定し，あるアプリケーションのみを実行することに特化したオペレーティングシステムになるよう，汎用オペレーティングシステムを自動的に改変することでカーネルを軽量化する手法を提案する．

アプリケーションが変わってもカーネルの自動軽量化が適用できるようにするため，
アプリケーションのソースコードを静的解析し，そのアプリケーションが必要とするオペレーティングシステムの機能を絞り込む．

また，アプリケーションが必要とする機能を実装する部分以外にも，ブートに必要な部分は削除しないようにする必要がある．
そこで，まず，カーネルソースコードを，ブートに必要な部分とそうでない部分に分類する必要がある．

アプリケーションのソースコードを静的解析して得た必要な部分と，ブートに必要な部分のみを残すよう，カーネルのソースコードを改変する．

\subsection{アプリケーションの静的解析}
\label{proposal:static}
オペレーティングシステムの機能をアプリケーションから利用するには，システムコールを呼び出す必要がある．
そこで，アプリケーションのソースコードを静的解析し，コールグラフを生成する．
アプリケーションのコールグラフから，システムコールの呼び出しを発見する．
呼び出しているシステムコールから，必要となるオペレーティングシステムの機能を絞り込むことができる．
アプリケーションが利用しているライブラリについても同様の解析を行い，システムコールの呼び出しを発見する必要がある．

また，カーネルのソースコードも静的解析を行い，コールグラフを生成する．
システムコールとしてアプリケーションに提供されているインターフェースとなる関数が，その内部で呼び出している関数を再帰的に発見する必要がある．
アプリケーションの静的解析によって必要であるとわかったシステムコールが，その内部で必要としている関数も，削除しないようにする必要があるためである．





\clearpage
\section{謝辞}
\label{sec-8}
\clearpage

\bibliographystyle{jplain}
\bibliography{ref}
% Emacs 24.5.1 (Org mode 8.2.10)
\end{document}
